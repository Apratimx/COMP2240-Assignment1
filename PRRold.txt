import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;

import javax.script.CompiledScript;

public class PRR
{
    // attributes
    private ArrayList<Process> PRRList;
    private ArrayList<String> tList;
    private ArrayList<Process> fList;
    Queue<Process> q;
    private int twt;        // total waiting time
    private int tta;        // total turnaround time

    // constructor
    public PRR()
    {
        this.PRRList = new ArrayList<Process>();
        this.tList = new ArrayList<String>();
        this.fList = new ArrayList<Process>();
        q = new LinkedList<Process>();
        this.twt = 0;
        this.tta = 0;
    }

    // methods
    public void feedProcess(ArrayList<Process> ogList, int dTime)
    {
        // deep element arraylist cloning
        for(int i = 0; i < ogList.size(); i++)
        {
            this.PRRList.add(ogList.get(i));
        }
        Collections.sort(PRRList, new sortByArrival());

        int cpuWatch = 0;
        sortArrive(PRRList);
        Process cProcess = null;

        // getting qualified processes
        for(int i = 0; i < PRRList.size(); i++)
        {
            if((PRRList.get(i).getArrive() <= cpuWatch) && (PRRList.get(i).getStatus() != 3))
            {
                q.add(PRRList.get(i));
            }
        }

        // business
        while(PRRList.size() > 0)
        {
            /*
            // TESTING
            System.out.println("id\tarrive\trun\texec\tcomplet\tstarts\tturnAr\twaiting\tstatus");
            for(int i = 0; i < ogList.size(); i++)
            {
                System.out.println(ogList.get(i).getId() + "(" + ogList.get(i).getPriority() + ")" + "\t" + ogList.get(i).getArrive() + "\t" + ogList.get(i).getRunningTime() + "\t" + ogList.get(i).getExecution() + "\t" + ogList.get(i).getCompletion() + "\t" + ogList.get(i).getOGStart() + "\t" + ogList.get(i).getTurnAround() + "\t" + ogList.get(i).getWaiting() + "\t" + ogList.get(i).getStatusLine());
            }
            System.out.println("********************************************************************************");
            */

            /*
            // TESTING
            System.out.println("id\tarrive\trun\texec\tcomplet\tstarts\tturnAr\twaiting\tstatus");
            Iterator<Process> pIterate = q.iterator();
            Process next = q.peek();
            //System.out.println(next.getId() + "(" + next.getPriority() + ")" + "\t" + next.getArrive() + "\t" + next.getRunningTime() + "\t" + next.getExecution() + "\t" + next.getCompletion() + "\t" + next.getOGStart() + "\t" + next.getTurnAround() + "\t" + next.getWaiting() + "\t" + next.getStatusLine());
            while(pIterate.hasNext())
            {
                next = pIterate.next();
                System.out.println(next.getId() + "(" + next.getPriority() + ")" + "\t" + next.getArrive() + "\t" + next.getRunningTime() + "\t" + next.getExecution() + "\t" + next.getCompletion() + "\t" + next.getOGStart() + "\t" + next.getTurnAround() + "\t" + next.getWaiting() + "\t" + next.getStatusLine());
            }
            System.out.println("********************************************************************************");
            */
            
            Process tProcess = q.poll();

            // getting qualified process
            ArrayList<Process> compMini = new ArrayList<Process>();
            for(int j = 0; j < PRRList.size(); j++)
            {
                if((PRRList.get(j).getArrive() <= cpuWatch) && (PRRList.get(j).getStatus() != 3))
                {
                    if(PRRList.get(j) != tProcess)
                    {
                        compMini.add(PRRList.get(j));
                    }
                }
            }
            if(compMini.size() != 0)
            {
                q.add(compMini.get(0));
            }
            compMini.clear();

            // NOT STARTED
            if(tProcess.getStatus() == 0)
            {
                cpuWatch += dTime;  // iterate watch

                // getting qualified processes
                for(int j = 0; j < PRRList.size(); j++)
                {
                    if((PRRList.get(j).getArrive() <= cpuWatch) && (PRRList.get(j).getStatus() != 3))
                    {
                        if(PRRList.get(j) != tProcess)
                        {
                            compMini.add(PRRList.get(j));
                        }
                    }
                }
                if( (compMini.size() != 0) && (compMini.get(0) != q.peek()) )
                {
                    q.add(compMini.get(0));
                }
                compMini.clear();

                tProcess.setStatus(1);
                tProcess.setStartsAt(cpuWatch);
                tProcess.setOGStart(cpuWatch);

                // iterate list depending on priority class
                if(tProcess.isHPC())
                {
                    for(int i = 0; i < 4; i++)
                    {
                        if(tProcess.getRunningTime() != tProcess.getExecution())
                        {
                            tProcess.iterateRun();
                            cpuWatch++;

                            // getting qualified processes
                            for(int j = 0; j < PRRList.size(); j++)
                            {
                                if((PRRList.get(j).getArrive() <= cpuWatch) && (PRRList.get(j).getStatus() != 3))
                                {
                                    if(PRRList.get(j) != tProcess)
                                    {
                                        compMini.add(PRRList.get(j));
                                    }
                                }
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    if(compMini.size() != 0)
                    {
                        if(compMini.get(0) != q.peek())
                        {
                            q.add(compMini.get(0));
                        }
                    }
                    compMini.clear();
                }
                else
                {
                    for(int i = 0; i < 2; i++)
                    {
                        if(tProcess.getRunningTime() != tProcess.getExecution())
                        {
                            tProcess.iterateRun();
                            cpuWatch++;

                            // getting qualified processes
                            for(int j = 0; j < PRRList.size(); j++)
                            {
                                if((PRRList.get(j).getArrive() <= cpuWatch) && (PRRList.get(j).getStatus() != 3))
                                {
                                    if(tProcess != PRRList.get(j))
                                    {
                                        compMini.add(PRRList.get(j));
                                    }
                                }
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    if(compMini.get(0) != q.peek())
                    {
                        q.add(compMini.get(0));
                    }
                    compMini.clear();
                }

                if(tList.size() == 0)
                {
                    String feed = "T" + tProcess.getStartsAt() + ": " + tProcess.getId() + "(" + tProcess.getPriority() + ")";
                    System.out.println(feed);
                    tList.add(feed);
                }

                if(cProcess != null)
                {
                    cProcess.setStatus(2);
                }
            }
            // RUNNING
            else if(tProcess.getStatus() == 1)
            {
                tProcess.iterateRun();
            }
            // PAUSED
            else if(tProcess.getStatus() == 2)
            {
                cpuWatch += dTime;

                // getting qualified processes
                for(int j = 0; j < PRRList.size(); j++)
                {
                    if((PRRList.get(j).getArrive() <= cpuWatch) && (PRRList.get(j).getStatus() != 3))
                    {
                        if(PRRList.get(j) != tProcess)
                        {
                            compMini.add(PRRList.get(j));
                        }
                    }
                }
                if( (compMini.size() != 0) && (compMini.get(0) != q.peek()))
                {
                    q.add(compMini.get(0));
                }
                compMini.clear();

                tProcess.setStartsAt(cpuWatch);
                
                if(tProcess.isHPC())
                {
                    for(int i = 0; i < 4; i++)
                    {
                        if(tProcess.getRunningTime() != tProcess.getExecution())
                        {
                            tProcess.iterateRun();
                            cpuWatch++;

                            // getting qualified processes
                            for(int j = 0; j < PRRList.size(); j++)
                            {
                                if((PRRList.get(j).getArrive() <= cpuWatch) && (PRRList.get(j).getStatus() != 3))
                                {
                                    if(PRRList.get(j) != tProcess)
                                    {
                                        compMini.add(PRRList.get(j));
                                    }
                                }
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    if(compMini.get(0) != q.peek())
                    {
                        q.add(compMini.get(0));
                    }
                    compMini.clear();
                }
                else
                {
                    for(int i = 0; i < 2; i++)
                    {
                        if(tProcess.getRunningTime() != tProcess.getExecution())
                        {
                            tProcess.iterateRun();
                            cpuWatch++;

                            // getting qualified processes
                            for(int j = 0; j < PRRList.size(); j++)
                            {
                                if((PRRList.get(j).getArrive() <= cpuWatch) && (PRRList.get(j).getStatus() != 3))
                                {
                                    if(tProcess != PRRList.get(j))
                                    {
                                        compMini.add(PRRList.get(j));
                                    }
                                }
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    if(compMini.get(0) != q.peek())
                    {
                        q.add(compMini.get(0));
                    }
                    compMini.clear();
                }

                tProcess.setStatus(1);
            }
            // FINISHED
            if(tProcess.getRunningTime() == tProcess.getExecution())
            {
                tProcess.setStatus(3);
                tProcess.setCompletion(cpuWatch);
                fList.add(tProcess);
                PRRList.remove(tProcess);
            }

            // selecting current process for next lot
            if(cProcess == null)
            {
                cProcess = tProcess;
            }
            else if(cProcess != tProcess)
            {
                cProcess = tProcess;
                String feed = "T" + cProcess.getStartsAt() + ": " + cProcess.getId() + "(" + cProcess.getPriority() + ")";
                System.out.println(feed);
                tList.add(feed);
            }


        }

        Collections.sort(fList, new sortByProcessId());
        for(int i = 0; i < fList.size(); i++)
        {
            // calculating turnaround/waiting times
            fList.get(i).setTurnAround(fList.get(i).getCompletion() - fList.get(i).getArrive());
            fList.get(i).setWaiting(fList.get(i).getTurnAround() - fList.get(i).getExecution());

            // accumulating total turnaround/waiting times
            tta += fList.get(i).getTurnAround();
            twt += fList.get(i).getWaiting();
        }

        // TESTING
        System.out.println("id\tarrive\trun\texec\tcomplet\tstarts\tturnAr\twaiting\tstatus");
        for(int i = 0; i < fList.size(); i++)
        {
            System.out.println(fList.get(i).getId() + "(" + fList.get(i).getPriority() + ")" + "\t" + fList.get(i).getArrive() + "\t" + fList.get(i).getRunningTime() + "\t" + fList.get(i).getExecution() + "\t" + fList.get(i).getCompletion() + "\t" + fList.get(i).getOGStart() + "\t" + fList.get(i).getTurnAround() + "\t" + fList.get(i).getWaiting() + "\t" + fList.get(i).getStatusLine());
        }
        System.out.println("********************************************************************************");

    }

    // sorting in accordance to arrival
    public ArrayList<Process> sortArrive(ArrayList<Process> processList)
    {
        Collections.sort(processList, Comparator.comparing(Process::getArrive)
            .thenComparing(Process::getArrive));
        return processList;
    }

    // start time | process id | process priority
    public void results()
    {
        for(int i = 0; i < tList.size(); i++)
        {
            System.out.println(tList.get(i));
        }
        System.out.println();
    }

    // process id | turnaround time | waiting time
    public void report()
    {
        Collections.sort(fList, new sortByProcessId());
        System.out.println("Process\tTurnaround Time\tWaiting Time");
        for(int  i = 0 ; i< fList.size();  i++)
        {
            System.out.println(fList.get(i).getId() + "\t" + fList.get(i).getTurnAround() + "\t\t" + fList.get(i).getWaiting() );
        }
        System.out.println();
    }

    public double getAverageTurnaroundTime()
    {
        return (double)this.tta / this.fList.size();
    }

    public double getAverageWaitingTime()
    {
        return (double)this.twt / this.fList.size();
    }
}